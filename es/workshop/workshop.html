
<!DOCTYPE HTML>
<html lang="es" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Introducción · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.2">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../styles/website.css">
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="workshop.html" />
    
    
    <link rel="prev" href="../environment/rust-playground.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Escribe para buscar" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    El taller
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Rust Playground</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="../environment/rust-playground.html">
            
                <a href="../environment/rust-playground.html#rust-playground">
            
                    
                    ¿Qué es Rust Playground?
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Taller</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="workshop.html">
            
                <a href="workshop.html#intro">
            
                    
                    Introducción
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.2" data-path="workshop.html">
            
                <a href="workshop.html#beginner">
            
                    
                    Tutorial para principiantes
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="3.2.1" data-path="workshop.html">
            
                <a href="workshop.html#ownership">
            
                    
                    Propiedad
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.2.2" data-path="workshop.html">
            
                <a href="workshop.html#borrows">
            
                    
                    Préstamo
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.2.3" data-path="workshop.html">
            
                <a href="workshop.html#mutable-borrows">
            
                    
                    Préstamos mutables
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="header">Preguntas en clase</li>
        
        
    
        <li class="chapter " data-level="4.1" data-path="faq.html">
            
                <a href="faq.html#reuse-names">
            
                    
                    ¿Se puede reutilizar una variable?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.2" data-path="faq.html">
            
                <a href="faq.html#value-or-reference">
            
                    
                    ¿Los datos se pasan por valor o por referencia?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.3" data-path="faq.html">
            
                <a href="faq.html#why-movement-semantics">
            
                    
                    ¿Por qué "mover un valor"? ¿Para qué sirve?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.4" data-path="faq.html">
            
                <a href="faq.html#display-and-debug">
            
                    
                    ¿Qué diferencia hay entre "{}" y "{:?}" cuando se usa con println!?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.5" data-path="faq.html">
            
                <a href="faq.html#string-refstring-refstr">
            
                    
                    ¿Qué diferencia hay entre String, &String y &str?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.6" >
            
                <span>
            
                    
                    ¿Qué representa String?
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="4.7" >
            
                <span>
            
                    
                    ¿Cuál es la representación interna de los objetos de Rust?
            
                </span>
            

            
        </li>
    

    
        
        <li class="header">Guía del taller</li>
        
        
    
        <li class="chapter " data-level="5.1" >
            
                <span>
            
                    
                    Público
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="5.2" >
            
                <span>
            
                    
                    Duración
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="5.3" >
            
                <span>
            
                    
                    Equipamiento
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="5.4" >
            
                <span>
            
                    
                    Objetivo
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="5.5" >
            
                <span>
            
                    
                    Consideraciones adicionales
            
                </span>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Publicado con GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Introducción</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="intro">Introducci&#xF3;n </h1>
<p>La programaci&#xF3;n de sistemas es aquella cuya finalidad es la de programar software que utilizar&#xE1;n otros programas. Un sistema operativo, un servidor HTTP o un motor de juegos son ejemplos de sistemas.</p>
<p>Este taller de Rust para absolutos novatos presenta y explica las caracter&#xED;sticas de Rust tratando de no compararlo con otros lenguajes. El texto, no obstante, asume que alguna vez has programado, aunque haya sido con lenguajes din&#xE1;micos o Web.</p>
<p>Comencemos con un sencillo programa de ejemplo para enumerar algunas caracter&#xED;sticas de la sintaxis de Rust.</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> name: <span class="hljs-built_in">String</span> = <span class="hljs-string">&quot;Salva&quot;</span>.to_string();
    <span class="hljs-keyword">let</span> greeting_length = greeting(name);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, greeting_length);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">greeting</span></span>(message: <span class="hljs-built_in">String</span>) -&gt; usize {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, {}&quot;</span>, message);
    <span class="hljs-number">7</span> + message.chars().count()
}
</code></pre>
<p>En Rust, las funciones comienzan con la palabra clave <code>fn</code> y la funci&#xF3;n llamada <code>main</code> es el punto de entrada.</p>
<p>Las variables se declaran con <code>let</code> acompa&#xF1;ado de un identificador y una inicializaci&#xF3;n obligatoria. El tipo <code>String</code>, indicado entre los dos puntos <code>:</code> y el igual <code>=</code> es opcional.</p>
<p>Antes de continuar, no puedo dejar de enfatizar que los sistemas de tipos no existen para hacer la programaci&#xF3;n m&#xE1;s complicada, sino que son herramientas de dise&#xF1;o: nos exigen coherencia en el software que constru&#xED;mos.</p>
<p>Rust es un lenguaje con un sistema de tipos modernos que permite omitir casi cualquier anotaci&#xF3;n de tipos. Rust intentar&#xE1; adivinar el tipo por el contexto, aplicando una t&#xE9;cnica llamada inferencia de tipos como ocurre con <code>greeting_length</code>. S&#xF3;lo en la signaturas de las funciones, Rust exige que los tipos se especifiquen expl&#xED;citamente.</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> v = <span class="hljs-built_in">vec!</span>();  <span class="hljs-comment">// Rust no puede deducir de qu&#xE9; clase de vector se trata.</span>
    v.push(<span class="hljs-number">1</span>);       <span class="hljs-comment">// Pero aqu&#xED;, Rust sabe que v es un vector de enteros.</span>
    v.push(<span class="hljs-string">&quot;mundo&quot;</span>); <span class="hljs-comment">// Y esto falla: &quot;mismatched types&quot;.</span>
}
</code></pre>
<p>Ademas, ante el error, el compilador de Rust siempre intentar&#xE1; ayudarnos, emitiendo la suficiente informaci&#xF3;n para <strong>contextualizar el error, explicarlo y solucionarlo</strong>. En Rust hay que acostumbrarse a leer los mensajes de error y colaborar con el compilador:</p>
<pre><code>error[E0308]: mismatched types
 --&gt; src/main.rs:5:12
  |
5 |     v.push(&quot;mundo&quot;); // Y esto falla: &quot;mismatched types&quot;.
  |            ^^^^^^^ expected integral variable, found reference
  |
  = note: expected type `{integer}`
             found type `&amp;&apos;static str`
</code></pre><p>Volviendo a la sintaxsis, podemos llamar m&#xE9;todos sobre valores usando el operador <code>.</code> como ocurre en <code>.to_string()</code> o en <code>.chars().count()</code>. La llamada a <code>.to_string()</code> es necesaria porque los literales de cadena tienen otro tipo por defecto. En los ejemplos tambi&#xE9;n te encontrar&#xE1;s esto escrito <a href="https://doc.rust-lang.org/std/macro.format.html" target="_blank"><code>format!(&quot;Literal de cadena&quot;)</code></a>.</p>
<p>El identificador <code>println!</code> no es una funci&#xF3;n al uso sino una <em>macro</em>. Una macro es un tipo de funci&#xF3;n que se ejecuta en tiempo de compilaci&#xF3;n y produce c&#xF3;digo Rust que reemplaza a la llamada.</p>
<p>Sin embargo, <code>greeting</code> s&#xED; que es una funci&#xF3;n m&#xE1;s, como <code>main</code>. En la signatura de la funci&#xF3;n, los tipos son obligatorios. Debemos indicar <strong>qu&#xE9; tipo de datos se esperan como par&#xE1;metros y el tipo de salida</strong>.</p>
<p>El valor de retorno de una funci&#xF3;n puede expresarse de dos maneras: o bien expl&#xED;citamente mediante la palabra clave <code>return</code>, o bien, de forma m&#xE1;s com&#xFA;n <strong>omitiendo el punto y coma al final de la &#xFA;ltima l&#xED;nea</strong>.</p>
<p>En Rust, el punto y coma <code>;</code> es un operador especial, que s&#xF3;lo puede omitirse al final de la &#xFA;ltima expresi&#xF3;n, y que, de estar presente, anula el resultado de dicha expresi&#xF3;n.</p>
<h2 id="beginners">Tutorial para principiantes </h2>
<p>Uno de los principales recursos de un ordenador es la memoria. La memoria es un espacio direccionable en el que se almacenan tanto los propios programas en ejecuci&#xF3;n como los datos con los que dicho programas van a trabajar.</p>
<p>Los programas en ejecuci&#xF3;n conviven juntos en memoria y es posible que un programa malintencionado invada el espacio de otro con el fin de controlarlo. En Rust, esta situaci&#xF3;n es imposible y por eso se dice de &#xE9;l que es un lenguaje de programaci&#xF3;n seguro.</p>
<p>Adem&#xE1;s, la memoria es un bien escaso. Los lenguajes de sistemas tratan de ocupar poco espacio para que sea el software al que dan servicio el que disfrute del grueso de la misma.</p>
<p>Para lograr estos objetivos, Rust posee los siguientes mecanismos, que exploraremos en esta primera parte del tutorial: propiedad, pr&#xE9;stamo y control de la mutabilidad.</p>
<p>Prueba a realizar el <a href="https://play.rust-lang.org/?code=%2F%2F+Goals%3A%0A%2F%2F+-+change+to+greet+you+by+name%0A%2F%2F+-+introduce+a+variable+%60name%60+and+insert+this+into+the+format+string%0A%2F%2F+-+try+%60println%21%28%22%7B%7D%22%2C+name%29%60+vs+%60println%21%28%22%7B%3A%3F%7D%22%2C+name%29%60+and+see+what+the+difference+is%0A%0Afn+main%28%29+%7B%0A++++println%21%28%22Hello%2C+world%21%22%29%3B%0A%7D%0A&amp;version=nightly" target="_blank">ejercicio 1</a> para ir familiariz&#xE1;ndote con el lenguaje.</p>
<h3 id="ownership">Propiedad </h3>
<p>La propiedad (u <em>ownership</em>, en ingl&#xE9;s) representa el <strong>los derechos de lectura y modificaci&#xF3;n; as&#xED; como el deber de destruir un objeto</strong>. La propiedad la tiene la funci&#xF3;n que crea el objeto y, por defecto, la propiedad se adquiere s&#xF3;lo con permiso de lectura <strong>pero no de escritura</strong>.</p>
<p>A menos que se especifique lo contrario, cuando pasamos un dato como par&#xE1;metro, transferimos la propiedad del dato a la funci&#xF3;n invocada, de forma que ya no podremos volver a acceder al mismo dato desde la funci&#xF3;n invocante. A esto se le llama &quot;mover un valor&quot;:</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> name: <span class="hljs-built_in">String</span> = <span class="hljs-string">&quot;Salva&quot;</span>.to_string();
    greeting(name);
    yell(name);      <span class="hljs-comment">// error, &quot;use of moved value: `name`&quot;</span>
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">greeting</span></span>(message: <span class="hljs-built_in">String</span>) {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, {}&quot;</span>, message);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">yell</span></span>(message: <span class="hljs-built_in">String</span>) {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}!!!&quot;</span>, message);
}
</code></pre>
<p>El compilador de Rust es bastante claro al indicar qu&#xE9; ha pasado:</p>
<pre><code>error[E0382]: use of moved value: `name`
 --&gt; src/main.rs:4:10
  |
3 |     greeting(name);
  |               ---- value moved here
4 |     yell(name);
  |          ^^^^ value used here after move
  |
  = note: move occurs because `name` has type `std::string::String`, which does not implement the `Copy` trait
</code></pre><p>Para que el c&#xF3;digo anterior compile, en lugar de mover el valor en la l&#xED;nea 3, podemos mover una copia del valor haciendo uso del m&#xE9;todo <code>.clone()</code>:</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> name: <span class="hljs-built_in">String</span> = <span class="hljs-string">&quot;Salva&quot;</span>.to_string();
    greeting(name.clone()); <span class="hljs-comment">// Ya no movemos `name` sino una copia de `name`.</span>
    yell(name);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">greeting</span></span>(message: <span class="hljs-built_in">String</span>) {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, {}&quot;</span>, message);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">yell</span></span>(message: <span class="hljs-built_in">String</span>) {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}!!!&quot;</span>, message);
}
</code></pre>
<p>Conviene hacer notar que igual que movemos un valor hacia el interior de una funci&#xF3;n, tambi&#xE9;n es posible mover el valor hacia el exterior, basta con usar el valor como parte de la expresi&#xF3;n de retorno:</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> name: <span class="hljs-built_in">String</span> = <span class="hljs-string">&quot;Salva&quot;</span>.to_string();
    <span class="hljs-keyword">let</span> former_name = greeting(name);
    yell(former_name);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">greeting</span></span>(message: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">String</span> {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, {}&quot;</span>, message);
    message
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">yell</span></span>(message: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">String</span> {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}!!!&quot;</span>, message);
    message
}
</code></pre>
<p>Antes de terminar, existe una notable excepci&#xF3;n al comportamiento por defecto de Rust. Observa como no es necesario llamar a <code>.clone()</code> sobre un n&#xFA;mero:</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> number = <span class="hljs-number">42</span>;
    greeting(number); <span class="hljs-comment">// Funciona.</span>
    yell(number);     <span class="hljs-comment">// Tambi&#xE9;n funciona.</span>
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">greeting</span></span>(message: <span class="hljs-keyword">i32</span>) {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, {}&quot;</span>, message);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">yell</span></span>(message: <span class="hljs-keyword">i32</span>) {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}!!!&quot;</span>, message);
}
</code></pre>
<p>En Rust, <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html#implementors" target="_blank">algunos tipos pueden marcarse como <code>Copy</code></a>, que significa que cada vez que se pasan, se realiza una <strong>copia impl&#xED;cita</strong>.</p>
<p>Echa un vistazo a <a href="http://www.rust-tutorials.com/RustConf17//PDF/10-Ownership.pdf" target="_blank">las diapositivas de este tema</a>, las cuales ilustran lo que ocurren en caso de movimiento, copia (<em>clone</em>) y copia impl&#xED;cita (<em>copy</em>) de un valor.</p>
<p>Practica lo que has aprendido con el <a href="https://play.rust-lang.org/?code=fn+main%28%29+%7B%0A++++let+%28adjective%2C+name%29+%3D+two_words%28%29%3B%0A++++let+name+%3D+format%21%28%22%7B%7D+%7B%7D%22%2C+adjective%2C+name%29%3B%0A++++print_out%28name%29%3B%0A%7D%0A%0Afn+two_words%28%29+-%3E+%28String%2C+String%29+%7B%0A++++%28format%21%28%22fellow%22%29%2C+format%21%28%22Rustaceans%22%29%29%0A%7D%0A%0Afn+remove_vowels%28name%3A+String%29+-%3E+String+%7B%0A++++%2F%2F+Goal+%231%3A+What+is+needed+here+to+make+this+compile%3F%0A++++let+output+%3D+String%3A%3Anew%28%29%3B%0A++++for+c+in+name.chars%28%29+%7B%0A++++++++match+c+%7B%0A++++++++++++%27a%27+%7C+%27e%27+%7C+%27i%27+%7C+%27o%27+%7C+%27u%27+%3D%3E+%7B%0A++++++++++++++++%2F%2F+skip+vowels%0A++++++++++++%7D%0A++++++++++++_+%3D%3E+%7B%0A++++++++++++++++output.push%28c%29%3B%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A++++output%0A%7D%0A%0Afn+print_out%28name%3A+String%29+%7B%0A++++let+devowelized_name+%3D+remove_vowels%28name%29%3B%0A++++println%21%28%22Removing+vowels+yields+%7B%3A%3F%7D%22%2C+devowelized_name%29%3B%0A%0A++++%2F%2F+Goal+%232%3A+What+happens+when+you+uncomment+the+%60println%60+below%3F%0A++++%2F%2F+Can+you+change+the+code+above+so+that+the+code+below+compiles%0A++++%2F%2F+successfully%3F%0A++++%2F%2F%0A++++%2F%2F+println%21%28%22Removing+vowels+from+%7B%3A%3F%7D+yields+%7B%3A%3F%7D%22%2C%0A++++%2F%2F++++++++++name%2C+devowelized_name%29%3B%0A%0A++++%2F%2F+Extra+credit%3A+Can+you+do+it+without+copying+any+data%3F%0A++++%2F%2F+%28Using+only+ownership+transfer%29%0A%7D%0A&amp;version=nightly" target="_blank">ejercicio 2</a>. Recuerda que el compilador de Rust <strong>es tu aliado</strong>, lee los mensajes de error con atenci&#xF3;n para obtener pistas acerca de c&#xF3;mo completar el ejercicio.</p>
<h3 id="borrows">Pr&#xE9;stamo </h3>
<p>Existe una forma de evitar el movimiento de un valor y aun as&#xED; no tener que copiarlo, simplificando el uso de nuestras funciones. Para ello Rust permite &quot;dar en pr&#xE9;stamo&quot; un valor. Puedes pensar que &quot;dar en pr&#xE9;stamo&quot; es realmente &quot;conceder permisos de lectura o escritura, temporalmente&quot;. Esta concesi&#xF3;n se realiza por medio de referencias y, a menos que es especifique expl&#xED;citamente, el acceso resultante es de s&#xF3;lo lectura:</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> name: <span class="hljs-built_in">String</span> = <span class="hljs-string">&quot;Salva&quot;</span>.to_string();
    greeting(&amp;name); <span class="hljs-comment">// Pasamos una referencia a la funci&#xF3;n.</span>
    yell(&amp;name);     <span class="hljs-comment">// Pasamos otra referencia a la funci&#xF3;n.</span>
                     <span class="hljs-comment">// El valor en `name` NUNCA se movi&#xF3;.</span>
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">greeting</span></span>(message: &amp;<span class="hljs-built_in">String</span>) {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, {}&quot;</span>, message);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">yell</span></span>(message: &amp;<span class="hljs-built_in">String</span>) {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}!!!&quot;</span>, message);
}
</code></pre>
<p>F&#xED;jate en la sint&#xE1;xis: el tipo <code>&amp;String</code> significa &quot;referencia a String&quot; y el mismo ampersand <code>&amp;</code> acompa&#xF1;ado de un valor como en <code>&amp;name</code> significa &quot;tomar una referencia al valor&quot;. Al pasar, devolver o asignar referencias estamos &quot;prestando el valor&quot;.</p>
<p>Las referencias son parte del tipo. <code>String</code> y <code>&amp;String</code> <strong>son tipos distintos</strong> de la misma forma que las expresiones <code>&quot;Salva&quot;.to_string()</code> y <code>&amp;&quot;Salva&quot;.to_string()</code> devuelven <strong>valores de tipos distintos</strong>.</p>
<p>Los pr&#xE9;stamos evitan el uso de copias sin tener que mover el valor <em>de vuelta</em>, lo que resulta en usos m&#xE1;s naturales de las funciones.</p>
<p>Adem&#xE1;s <strong>los pr&#xE9;stamos no transfieren la propiedad</strong>. El encargado de destruir el dato creado lo mantiene la funci&#xF3;n desde la que se tom&#xF3; el pr&#xE9;stamo. El pr&#xE9;stamo termina cuando la referencia se destruye, normalmente al final de la funci&#xF3;n.</p>
<p>Puedes pensar en una referencia como en un &quot;portal m&#xE1;gico&quot; por el que mirar a otro lugar. El portal a un valor se obtiene prefijando el valor con <code>&amp;</code>. La funci&#xF3;n que crea el portal pasa una copia del portal a las funciones llamadas pero no toca el lugar original. Cuando la funci&#xF3;n que ha usado el portal termina, tambi&#xE9;n destruye su copia del portal lo que no afecta a aquello que se viera a trav&#xE9;s de &#xE9;l.</p>
<p>Trata de adaptar t&#xFA; el <a href="http://is.gd/no0tTH" target="_blank">siguiente ejemplo</a>.</p>
<p>Es importante recordar que el acceso por defecto de Rust es de <strong>s&#xF3;lo lectura</strong>. Esto quiere decir que, a menos que se especifique expl&#xED;citamente, no podemos alterar el valor de una variable...</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;Salva&quot;</span>.to_string();
    name.push(<span class="hljs-string">&apos;!&apos;</span>); <span class="hljs-comment">// error, &quot;cannot borrow immutable local variable `name` as mutable&quot;</span>
}
</code></pre>
<p>...ni de una referencia:</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;Salva&quot;</span>.to_string();
    emphasis(&amp;name);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">emphasis</span></span>(message: &amp;<span class="hljs-built_in">String</span>) {
    message.push(<span class="hljs-string">&apos;!&apos;</span>); <span class="hljs-comment">// error, cannot borrow immutable borrowed content `*message` as mutable</span>
}
</code></pre>
<h4 id="sint&#xE1;xis-de-alto-nivel-y-eficiencia-de-bajo-nivel">Sint&#xE1;xis de alto nivel y eficiencia de bajo nivel</h4>
<p>Adem&#xE1;s de un lenguaje de sistemas, Rust es un <strong>lenguaje moderno, de alto nivel</strong> por lo que ofrece estructuras sint&#xE1;cticas avanzadas al tiempo que evita copias o reservas de memoria.</p>
<p>Es el caso con las porciones (comunmente conocidas como <em>slices</em>), en las que nos referimos a un subrango de un vector:</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> name: <span class="hljs-built_in">String</span> = <span class="hljs-string">&quot;Salva&quot;</span>.to_string();
    greeting(&amp;name);
    greeting(&amp;name[<span class="hljs-number">1</span>..]);    <span class="hljs-comment">// Esto es una porci&#xF3;n o slice, desde el segundo</span>
                             <span class="hljs-comment">// elemento en adelante.</span>
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">greeting</span></span>(message: &amp;<span class="hljs-keyword">str</span>) { <span class="hljs-comment">// Hemos cambiado la signatura de la funci&#xF3;n aqu&#xED;.</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, {}&quot;</span>, message);
}
</code></pre>
<p>O tambi&#xE9;n de las iteraciones:</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> names: <span class="hljs-built_in">String</span> = <span class="hljs-string">&quot;Salva Fernando Juan&quot;</span>.to_string();
    greeting(&amp;names);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">greeting</span></span>(message: &amp;<span class="hljs-keyword">str</span>) {
    <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> message.split(<span class="hljs-string">&apos; &apos;</span>) { <span class="hljs-comment">// No hay copia alguna de los datos.</span>
      <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, {}&quot;</span>, name);
    }
}
</code></pre>
<p>Ninguno de los ejemplos anteriores involucra copias de ning&#xFA;n modo. Puedes repasar las <a href="http://www.rust-tutorials.com/RustConf17//PDF/20-Sharing.pdf" target="_blank">diapositivas de este tema</a> que incluyen representaciones de la memoria en estos casos para comprobar que las copias no son necesarias.</p>
<p>Cuando creas conveniente, practica con el <a href="https://play.rust-lang.org/?code=pub+fn+main%28%29+%7B%0A++++let+string+%3D+format%21%28%22my+friend%22%29%3B%0A++++greet%28string.clone%28%29%29%3B%0A++++greet%28string%29%3B%0A%7D%0A%0Afn+greet%28name%3A+String%29+%7B%0A++++println%21%28%22Hello%2C+%7B%7D%21%22%2C+name%29%3B%0A%7D%0A%0A%2F%2F+Goal+%231%3A+Convert+%60greet%60+to+use+borrowing%2C+not+ownership%2C+so+that%0A%2F%2F+this+program+executes+without+doing+any+cloning.%0A%2F%2F%0A%2F%2F+Goal+%232%3A+Use+a+subslice+so+that+it+prints+%22Hello%2C+friend%22+instead+of%0A%2F%2F+%22Hello%2C+my+friend%22.%0A&amp;version=nightly" target="_blank">siguiente ejercicio</a>.</p>
<h3 id="mutable-borrows">Pr&#xE9;stamos mutables </h3>
<p>Es posible pasar una referencia mutable a una funci&#xF3;n. O visto de otra forma, &#xBF;recuerdas el &quot;portal m&#xE1;gico&quot; de la lecci&#xF3;n anterior? Pues es posible pasar un portal a trav&#xE9;s del cual podamos acceder f&#xED;sicamente y manipular el objeto al otro lado.</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;Salva&quot;</span>.to_string();
    complete(&amp;<span class="hljs-keyword">mut</span> name);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Complete name: {}&quot;</span>, name);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">complete</span></span>(s: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">String</span>) {
    s.push_str(<span class="hljs-string">&quot;dor&quot;</span>);
}
</code></pre>
<p>F&#xED;jate en la nueva sint&#xE1;xis: ahora el tipo esperado en la funci&#xF3;n <code>complete()</code> es <code>&amp;mut String</code> o &quot;referencia mutable a String&quot;, y de la misma forma, la expresi&#xF3;n <code>name</code> se precede de <code>&amp;mut</code> que obtiene una referencia mutable al valor.</p>
<p>El ejemplo anterior <strong>no funciona</strong>. El compilador de Rust dice:</p>
<pre><code>error[E0596]: cannot borrow immutable local variable `name` as mutable
 --&gt; src/main.rs:4:19
  |
3 |     let name = &quot;Salva&quot;.to_string();
  |         ---- consider changing this to `mut name`
4 |     complete(&amp;mut name);
  |                   ^^^^ cannot borrow mutably
</code></pre><p>Esto es as&#xED; porque si realizamos un pr&#xE9;stamo mutable, debemos aceptar que el valor <code>name</code> (del que aun tenemos la propiedad) pueda cambiar y debemos indicarlo expl&#xED;citamente:</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> name = <span class="hljs-string">&quot;Salva&quot;</span>.to_string(); <span class="hljs-comment">// f&#xED;jate en que ahora name es mutable.</span>
    complete(&amp;<span class="hljs-keyword">mut</span> name);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Complete name: {}&quot;</span>, name);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">complete</span></span>(s: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">String</span>) {
    s.push_str(<span class="hljs-string">&quot;dor&quot;</span>);
}
</code></pre>
<p>Antes de continuar, repasa los pr&#xE9;stamos sin mutabilidad <a href="https://play.rust-lang.org/?code=fn%20main%28%29%20%7B%0A%20%20%20%20let%20name%20%3D%20format!%28%22fellow%20Rustaceans%22%29%3B%0A%20%20%20%20helper%28name%29%3B%0A%20%20%20%20helper%28name%29%3B%0A%7D%0A%0Afn%20helper%28name%3A%20String%29%20%7B%0A%20%20%20%20println!%28%22Hello%2C%20%7B%7D!%22%2C%20name%29%3B%0A%7D&amp;version=stable" target="_blank">haciendo que este ejemplo compile</a>.</p>
<h4 id="preservando-la-seguridad">Preservando la seguridad</h4>
<p>Prestar valores indistintamente para lectura o escritura entra&#xF1;a diversos riesgos: en un escenario concurrente donde las lecturas y escrituras de varias funciones pueden entremezclarse, es posible que los valores se modifiquen justo despu&#xE9;s de que las lecturas se produzcan y se tomen decisiones en funci&#xF3;n de datos desactualizados, llevando a falsas asunciones y a resultados incorrectos.</p>
<p>En un escenario sin concurrencia, la alteraci&#xF3;n de algunos valores puede llevar a recolocarlos en la memoria haciendo que otras referencias a los mismos queden desactualizadas.</p>
<p>Para evitar estas situaciones, Rust establece una regla:</p>
<ul>
<li>No puede haber, jam&#xE1;s, un pr&#xE9;stamo de lectura y otro de escritura simultaneos.</li>
</ul>
<p>Si tal situaci&#xF3;n pudiera producirse, Rust <strong>no compilar&#xE1; el programa</strong>. Conviene recordar que la obtenci&#xF3;n de una referencia mutable confiere tambi&#xE9;n un permiso de lectura por lo que no pueden producirse dos pr&#xE9;stamos mutables al mismo tiempo. En t&#xE9;rminos de mutabilidad, esta regla se traduce en dos:</p>
<ol>
<li>Un &#xFA;nico pr&#xE9;stamo mutable...</li>
<li>...o m&#xFA;ltiples pr&#xE9;stamos inmutables y ninguno mutable.</li>
</ol>
<p>Por ejemplo:</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> name = <span class="hljs-string">&quot;Salva&quot;</span>.to_string();
    <span class="hljs-keyword">let</span> end = &amp;name[<span class="hljs-number">1</span>..];
    complete(&amp;<span class="hljs-keyword">mut</span> name);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, {}!&quot;</span>, name);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">complete</span></span>(name: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">String</span>) {
    name.push_str(<span class="hljs-string">&quot;dor&quot;</span>);
}
</code></pre>
<p>El c&#xF3;digo anterior falla al compilar porque &quot;no se puede prestar <code>name</code> como mutable porque tambi&#xE9;n se ha prestado como inmutable&quot;:</p>
<pre><code>error[E0502]: cannot borrow `name` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:4:19
  |
3 |     let end = &amp;name[1..];
  |                ---- immutable borrow occurs here
4 |     complete(&amp;mut name);
  |                   ^^^^ mutable borrow occurs here
5 |     println!(&quot;Hello, {}!&quot;, name);
6 | }
  | - immutable borrow ends here
</code></pre><p>Las <a href="http://www.rust-tutorials.com/RustConf17//PDF/25-Mutable%20borrows.pdf" target="_blank">diapositivas sobre mutabilidad</a> explican con ejemplos visuales una situaci&#xF3;n en la que un valor crece hasta el punto de tener que ser recolocado en memoria.</p>
<p>Primero <a href="https://play.rust-lang.org/?code=pub+fn+main%28%29+%7B%0A++++let+%28mut+str1%2C+str2%29+%3D+two_words%28%29%3B%0A++++str1+%3D+join_words%28str1%2C+str2%29%3B%0A++++println%21%28%22concatenated+string+is+%7B%3A%3F%7D%22%2C+str1%29%3B%0A%7D%0A%0Afn+two_words%28%29+-%3E+%28String%2C+String%29+%7B%0A++++%28format%21%28%22fellow%22%29%2C+format%21%28%22Rustaceans%22%29%29%0A%7D%0A%0A%2F%2F%2F+Concatenate+%60suffix%60+onto+the+end+of+%60prefix%60.%0Afn+join_words%28mut+prefix%3A+String%2C+suffix%3A+String%29+-%3E+String+%7B%0A++++prefix.push%28%27+%27%29%3B+%2F%2F+separate+the+words+with+a+space%0A++++for+ch+in+suffix.chars%28%29+%7B%0A++++++++prefix.push%28ch%29%3B%0A++++%7D%0A++++prefix%0A%7D%0A%0A%2F%2F+Challenge%3A+Convert+%60join_words%60+to+use+borrowing%2C+not+ownership.%0A%2F%2F+The+new+function+should+mutate+%60prefix%60+in+place%2C+and+should+not%0A%2F%2F+take+ownership+of+%60suffix%60.%0A%2F%2F%0A%2F%2F+Hint%3A+If+you%27d+like+a+hint+as+to+how+to+proceed%2C+open%0A%2F%2F+%3Chttp%3A%2F%2Frust-tutorials.com%2FRustConf17%2F%2Fhint%2Fmutable_borrow_1%2F%3E.%0A%0A%2F%2F+Question%3A+Now+that+you%27ve+converted+%60join_words%60%2C+what+happens+if+you%0A%2F%2F+call+%60join_words%60+using+the+same+string+for+%60prefix%60+and+%60suffix%60%3F%0A%2F%2F+Why%3F%0A&amp;version=nightly" target="_blank">completa el ejercicio de esta lecci&#xF3;n</a> y luego trata de responder a la pregunta planteada antes de probar a compilar bajo el nuevo supuesto.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../environment/rust-playground.html#rust-playground" class="navigation navigation-prev " aria-label="Previous page: ¿Qué es Rust Playground?">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="workshop.html#beginner" class="navigation navigation-next " aria-label="Next page: Tutorial para principiantes">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Introducción","level":"3.1","depth":1,"next":{"title":"Tutorial para principiantes","level":"3.2","depth":1,"anchor":"#beginner","path":"workshop/workshop.md","ref":"workshop/workshop.md#beginner","articles":[{"title":"Propiedad","level":"3.2.1","depth":2,"anchor":"#ownership","path":"workshop/workshop.md","ref":"workshop/workshop.md#ownership","articles":[]},{"title":"Préstamo","level":"3.2.2","depth":2,"anchor":"#borrows","path":"workshop/workshop.md","ref":"workshop/workshop.md#borrows","articles":[]},{"title":"Préstamos mutables","level":"3.2.3","depth":2,"anchor":"#mutable-borrows","path":"workshop/workshop.md","ref":"workshop/workshop.md#mutable-borrows","articles":[]}]},"previous":{"title":"¿Qué es Rust Playground?","level":"2.1","depth":1,"anchor":"#rust-playground","path":"environment/rust-playground.md","ref":"environment/rust-playground.md#rust-playground","articles":[]},"dir":"ltr"},"config":{"plugins":[],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"language":"es","gitbook":"*"},"file":{"path":"workshop/workshop.md","mtime":"2018-05-28T20:26:53.255Z","type":"markdown"},"gitbook":{"version":"3.2.2","time":"2018-05-28T20:27:06.883Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

